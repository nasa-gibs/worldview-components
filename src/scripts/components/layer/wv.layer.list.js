import React from 'react';
import PropTypes from 'prop-types';
import LayerRow from './wv.layer.row.js';
import { CellMeasurer, CellMeasurerCache, List } from 'react-virtualized';

/*
 * A scrollable list of layers
 * @class LayerList
 * @extends React.Component
 */
class LayerList extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      layerFilter: props.config.layerOrder,
      expandedLayers: [],
      width: props.width,
      height: props.height,
      metadata: props.metadata,
      descriptions: {},
      requestPool:[]
    };
    this._cache = new CellMeasurerCache({
      fixedWidth: true,
      minHeight: 23,
      minWidth: this.state.width
    });
  }
  /*
   * Adds item to a state array of requested elements
   *
   * @method addToRequestPool
   * @param {Number} rowIndex - index of row
   * @return {void}
   */
  addToRequestPool(rowIndex) {
    var array = this.state.requestPool;
    array.push('row_' + rowIndex);
    this.setState({
      requestPool: array
    });
    array = null;
  }
  /*
   * Adds item to a state array of requested elements
   *
   * @method updateDescriptions
   * @param {Number} rowIndex - index of row
   * @param {String} description - description of layer
   * @return {void}
   */
  updateDescriptions(rowIndex, description) {
    var obj = this.state.descriptions;
    obj['row_' + rowIndex] = description;
    this.setState({
      descriptions: obj
    });
    obj = null;
  }
  componentWillUpdate(){
    // The List component will use the previously calculated row heights when
    // things change, unless we clear the CellMeasurerCache here
    this._cache.clearAll();
  }

  componentDidUpdate(prevProps, prevState){
    // The List component calculates row height based on the previous width
    // So if width changes (usually on window resize), we need to force a re-render
    // This is hacky, and triggers a liner warning because it causes a layout thrash
    // More info: https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-did-update-set-state.md
    // The only other solution I could think of is to refactor the whole component
    if (prevState.width && prevState.width !== this.state.width) {
      this.setState({width: this.state.width}); //Force re-render if width changes
    }
  }

  /*
   * Toggles expansion of metadata for a layer given that layer's ID
   * @method toggleExpansion
   * @param {string} layer - the layer to be toggled
   * @return {void}
   */
  toggleExpansion(layerId){
    var { expandedLayers } = this.state;
    var index = expandedLayers.indexOf(layerId);
    if(index > -1){
      expandedLayers.splice(index, 1); // Removes layer from expanded list
    } else {
      expandedLayers.push(layerId);
    }
    this.setState({ expandedLayers: expandedLayers });
  }

  /*
   * Recalculates the row height for a given rowIndex
   * @method recalculateRowHeight
   * @param {number} rowIndex - Index of the row to be recalculated
   * @return {void}
   */
  recalculateRowHeight (rowIndex){
    this._cache.clear(rowIndex, 0);
    this._layerList.recomputeRowHeights(rowIndex);
    this._layerList.scrollToRow(rowIndex);
  }

  /*
   * Renders a single row, given it's index.
   * See https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#rowrenderer
   * @method _rowRenderer
   * @param {object} options - props used to render the row
   * @return {void}
   */
  _rowRenderer ({ index, key, parent, style }) {
    var { model, config } = this.props;
    var { layerFilter, expandedLayers, requestPool, descriptions} = this.state;
    var currentLayerId = layerFilter[index];
    var currentLayer = config.layers[currentLayerId];
    var isEnabled = model.active.map(layer=>layer.id).includes(currentLayerId);
    var metaId = 'row_' + index;
    var isExpanded = expandedLayers.includes(currentLayerId);
    var metadata = descriptions[metaId];
    var isDescriptionLoaded = (descriptions[metaId]) ? true : false;
    var hasBeenRequested = (requestPool.indexOf(metaId) != -1);
    // Add paddingTop:5 to the style object generated by List component
    style = Object.assign({}, style, {paddingTop:5});
    return (
      <CellMeasurer
        cache={this._cache}
        columnIndex={0}
        key={key}
        parent={parent}
        rowIndex={index}
      >
        {({ measure }) => (
          <LayerRow
            key={currentLayerId + key}
            layerId={currentLayerId}
            title={currentLayer.title}
            subtitle={currentLayer.subtitle}
            isEnabled={isEnabled}
            metadata={metadata}
            toggleExpansion={layerId=>this.toggleExpansion(layerId)}
            isExpanded={isExpanded}
            isDescriptionLoaded={isDescriptionLoaded}
            hasBeenRequested={hasBeenRequested}
            description={config.layers[currentLayerId].description}
            updateDescriptions={this.updateDescriptions.bind(this)}
            addToRequestPool={this.addToRequestPool.bind(this)}
            style={style}
            rowIndex={index}
            onState={model.add}
            offState={model.remove}
            onChange={index=>this.recalculateRowHeight(index)}
            onLoad={measure}
          />
        )}
      </CellMeasurer>
    );
  }
  render() {
    var { height, width, layerFilter} = this.state;
    return(
      <div>
        <List
          deferredMeasurementCache={this._cache}
          id="flat-layer-list"
          width={width}
          height={height}
          style={{overflowY: 'scroll' /* Force scrollbars to always appear even in short lists to avoid inaccurate width calculations */ }}
          overscanRowCount={5}
          ref={ref=>this._setListRef(ref)}
          rowCount={layerFilter.length}
          rowHeight={this._cache.rowHeight}
          scrollToAlignment="auto"
          rowRenderer={row=>this._rowRenderer(row)}
        />
      </div>
    );
  }
  _setListRef (ref) { this._layerList = ref; }
}

LayerList.propTypes = {
  config: PropTypes.object,
  width: PropTypes.number,
  model: PropTypes.object,
  metadata: PropTypes.object,
  height: PropTypes.number,
  isMetadataLoaded: PropTypes.bool
}

export default LayerList;
