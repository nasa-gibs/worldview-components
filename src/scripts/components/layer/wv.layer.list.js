import React from 'react';
import PropTypes from 'prop-types';
import LayerRow from './wv.layer.row.js';
import { CellMeasurer, CellMeasurerCache, List } from 'react-virtualized';

/*
 * A scrollable list of layers
 * @class LayerList
 * @extends React.Component
 */
class LayerList extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      layerFilter: props.config.layerOrder,
      expandedLayers: [],
      width: props.width,
      height: props.height,
      isMetadataLoaded: props.isMetadataLoaded,
      metadata: props.metadata
    };
    this._cache = new CellMeasurerCache({
      fixedWidth: true,
      minHeight: 23,
      minWidth: this.state.width
    });
  }

  componentWillUpdate(){
    // The List component will use the previously calculated row heights when
    // things change, unless we clear the CellMeasurerCache here
    this._cache.clearAll();
  }

  componentDidUpdate(prevProps, prevState){
    // The List component calculates row height based on the previous width
    // So if width changes (usually on window resize), we need to force a re-render
    // This is hacky, and triggers a liner warning because it causes a layout thrash
    // More info: https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-did-update-set-state.md
    // The only other solution I could think of is to refactor the whole component
    if (prevState.width && prevState.width !== this.state.width) {
      this.setState({width: this.state.width}); //Force re-render if width changes
    }
  }

  /*
   * Toggles expansion of metadata for a layer given that layer's ID
   * @method toggleExpansion
   * @param {string} layer - the layer to be toggled
   * @return {void}
   */
  toggleExpansion(layer){
    var { expandedLayers } = this.state;
    var index = expandedLayers.indexOf(layer);
    if(index > -1){
      expandedLayers.splice(index, 1); // Removes layer from expanded list
    } else {
      expandedLayers.push(layer);
    }
    this.setState({ expandedLayers: expandedLayers });
  }

  /*
   * Recalculates the row height for a given rowIndex
   * @method recalculateRowHeight
   * @param {number} rowIndex - Index of the row to be recalculated
   * @return {void}
   */
  recalculateRowHeight (rowIndex){
    this._cache.clear(rowIndex, 0);
    this._layerList.recomputeRowHeights(rowIndex);
    this._layerList.scrollToRow(rowIndex);
  }

  /*
   * Renders a single row, given it's index.
   * See https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#rowrenderer
   * @method _rowRenderer
   * @param {object} options - props used to render the row
   * @return {void}
   */
  _rowRenderer ({ index, key, parent, style }) {
    var { model, config } = this.props;
    var { layerFilter, expandedLayers, metadata } = this.state;
    var currentLayerId = layerFilter[index];
    var currentLayer = config.layers[currentLayerId];
    var isEnabled = model.active.map(layer=>layer.id).includes(currentLayerId);
    var isExpanded = expandedLayers.includes(currentLayerId);
    // Add paddingTop:5 to the style object generated by List component
    style = Object.assign({}, style, {paddingTop:5});
    return (
      <CellMeasurer
        cache={this._cache}
        columnIndex={0}
        key={key}
        parent={parent}
        rowIndex={index}
      >
        {({ measure }) => (
          <LayerRow
            key={currentLayerId + key}
            layerId={currentLayerId}
            title={currentLayer.title}
            subtitle={currentLayer.subtitle}
            isEnabled={isEnabled}
            metadata={metadata[currentLayerId] || null}
            expand={layer=>this.toggleExpansion(layer)}
            isExpanded={isExpanded}
            style={style}
            rowIndex={index}
            onState={model.add}
            offState={model.remove}
            onChange={index=>this.recalculateRowHeight(index)}
            onLoad={measure}
          />
        )}
      </CellMeasurer>
    );
  }
  render() {
    var { height, width, layerFilter, isMetadataLoaded } = this.state;
    return(
      <div>
        {(!isMetadataLoaded) ? <div className='loader'> Loading layer descriptions... </div> : null}
        <List
          deferredMeasurementCache={this._cache}
          id="flat-layer-list"
          width={width}
          height={height}
          style={{overflowY: 'scroll' /* Force scrollbars to always appear even in short lists to avoid inaccurate width calculations */ }}
          overscanRowCount={5}
          ref={ref=>this._setListRef(ref)}
          rowCount={layerFilter.length}
          rowHeight={this._cache.rowHeight}
          scrollToAlignment="auto"
          rowRenderer={row=>this._rowRenderer(row)}
        />
      </div>
    );
  }
  _setListRef (ref) { this._layerList = ref; }
}

LayerList.propTypes = {
  config: PropTypes.object,
  initialWidth: PropTypes.number,
  model: PropTypes.object,
  metadata: PropTypes.object,
  initialHeight: PropTypes.number
}

export default LayerList;
